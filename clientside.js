// Generated by CoffeeScript 1.4.0
(function() {
  var $, Backbone, async, bootstrap, comm, consoleLogger, cook, env, flot, gatherInfo, helpers, init, initLogger, initStreamReader, initWebsocket, initdict, logger, randomWalk, settings, websocketConnect, _,
    __slice = [].slice;

  bootstrap = require('bootstrap-browserify');

  comm = require('comm/clientside');

  Backbone = require('backbone4000');

  helpers = require('helpers');

  _ = require('underscore');

  $ = require('jquery-browserify');

  async = require('async');

  flot = require('flot');

  settings = {
    websockethost: "http://" + window.location.host,
    simulatedelay: true
  };

  env = {};

  window.env = env;

  env.settings = settings;

  logger = comm.MsgNode.extend4000({
    log: function() {
      var data, tags, tagshash, text;
      text = arguments[0], data = arguments[1], tags = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      tagshash = {};
      _.map(tags, function(tag) {
        return tagshash[tag] = true;
      });
      return this.msg({
        tags: tagshash,
        text: text,
        data: data,
        time: new Date().getTime()
      });
    }
  });

  consoleLogger = consoleLogger = logger.extend4000({
    initialize: function() {
      return this.subscribe(true, function(msg, reply, next, transmit) {
        var json, text;
        text = msg.text;
        if (msg.tags.error && _.keys(msg.data).length) {
          json = " " + JSON.stringify(msg.data);
        } else {
          json = "";
        }
        console.log(_.keys(msg.tags).join(', ') + " " + text + json);
        reply.end();
        next();
        return transmit();
      });
    }
  });

  initLogger = function(env, callback) {
    env.logger = new logger();
    env.consoleLogger = new consoleLogger();
    env.logger.pass();
    env.logger.connect(env.consoleLogger);
    env.log = env.logger.log.bind(env.logger);
    env.logres = function(name, callback) {
      return function(err, data) {
        if (err) {
          env.log(name, {
            error: err
          }, 'init', 'fail');
        } else {
          env.log(name, {}, 'init', 'ok');
        }
        return callback(err, data);
      };
    };
    env.log('logger', {}, 'init', 'ok');
    return callback();
  };

  gatherInfo = function(env, callback) {
    var crawl;
    env.hostdata = {};
    crawl = function(object, attributes) {
      return helpers.hashmap(attributes, function(value, attr) {
        return object[attr];
      });
    };
    env.hostdata.browser = crawl(navigator, ['appCodeName', 'appVersion', 'userAgent', 'vendor']);
    env.hostdata.screen = crawl(window.screen, ['height', 'width', 'colorDepth']);
    env.hostdata.os = {
      platform: navigator.platform,
      language: navigator.language
    };
    return callback();
  };

  initWebsocket = function(env, callback) {
    var websocket;
    env.websocket = websocket = new comm.WebsocketClient({
      realm: 'web'
    });
    return callback();
  };

  websocketConnect = function(env, callback) {
    var doconnect;
    doconnect = function() {
      return env.websocket.connect(env.settings.websockethost, function() {
        return callback();
      });
    };
    if (window.location.hostname !== 'localhost' || env.settings.simulatedelay !== true) {
      return doconnect();
    } else {
      return setTimeout(doconnect, 400);
    }
  };

  initdict = {
    logger: function(callback) {
      return initLogger(env, callback);
    },
    gatherinfo: [
      'logger', function(callback) {
        return gatherInfo(env, env.logres('host info', callback));
      }
    ],
    websocket: [
      'logger', function(callback) {
        return initWebsocket(env, env.logres('initializing websocket', callback));
      }
    ],
    websocketconnect: [
      'websocket', function(callback) {
        return websocketConnect(env, env.logres('connecting websocket', callback));
      }
    ],
    streamreader: [
      'streamReader', function(callback) {
        return initStreamReader(env, env.logres('initializing stream reader', callback));
      }
    ]
  };

  init = function(env, callback) {
    return async.series([initdict.logger, _.last(initdict.gatherinfo), _.last(initdict.websocket), _.last(initdict.websocketconnect), _.last(initdict.streamreader)], callback);
  };

  init(env, function(err, data) {
    if (err) {
      env.log('clientside init failed', {}, 'init', 'fail', 'error');
      return;
    }
    return env.log('clientside ready', {}, 'init', 'ok', 'completed');
  });

  randomWalk = function(data, len) {
    var last;
    if (len == null) {
      len = 300;
    }
    if (!(data != null ? data.length : void 0)) {
      data = [50];
    }
    last = _.last(data);
    data.push(last + helpers.randrange(10) - 5);
    if (data.length > len) {
      data.shift();
      return data;
    } else {
      return randomWalk(data, len);
    }
  };

  cook = function(data) {
    var max;
    max = _.reduce(data, function(r, x) {
      if (!r) {
        r = 0;
      }
      if (x > r) {
        return x;
      } else {
        return r;
      }
    });
    return {
      lines: {
        show: true,
        fill: true
      },
      points: {
        show: false
      },
      data: data = _.map(data, function(n, i) {
        return [i, n / max];
      })
    };
  };

  initStreamReader = function(env, callback) {
    var DataStream, streams;
    DataStream = (function() {

      function DataStream(init) {
        var graphwindow,
          _this = this;
        this.maxlen = init.maxlen || 200;
        this.name = init.name || (function() {
          throw 'no name?';
        })();
        this.data = init.data || [0];
        graphwindow = $("<div class='window'></div>");
        graphwindow.append($("<div class='graphtitle'>" + this.name + "</div>"));
        graphwindow.append(this.div = $("<div class='graphcontainer'></div>"));
        $(document.body).append(graphwindow);
        this.plot = $.plot(this.div, [cook(this.data)], {
          series: {
            shadowSize: 0
          },
          yaxis: {
            show: false,
            min: 0,
            max: 1
          },
          xaxis: {
            show: false,
            min: 0,
            max: this.maxlen
          }
        });
        env.websocket.subscribe({
          stream: this.name
        }, function(msg, reply) {
          reply.end();
          return _this.push(msg.value);
        });
      }

      DataStream.prototype.redraw = function() {
        this.plot.setData([cook(this.data)]);
        return this.plot.draw();
      };

      DataStream.prototype.push = function(value) {
        this.data.push(value);
        if (this.data.length > (this.maxlen + 1)) {
          this.data.shift();
        }
        return this.redraw();
      };

      return DataStream;

    })();
    streams = {};
    env.websocket.subscribe({
      stream: true,
      value: true
    }, function(msg, reply, next, transmit) {
      if (!streams[msg.stream]) {
        streams[msg.stream] = new DataStream({
          name: msg.stream,
          data: [msg.value]
        });
      }
      return next();
    });
    return callback();
  };

}).call(this);
