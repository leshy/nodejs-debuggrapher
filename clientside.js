// Generated by CoffeeScript 1.4.0
(function() {
  var $, async, backbone, bootstrap, comm, consoleLogger, cook, env, flot, gatherInfo, getmax, helpers, init, initLogger, initStreamReader, initWebsocket, initdict, logger, randomWalk, settings, v, validator, websocketConnect, _,
    __slice = [].slice;

  bootstrap = require('bootstrap-browserify');

  comm = require('comm/clientside');

  backbone = require('backbone4000');

  helpers = require('helpers');

  _ = require('underscore');

  $ = require('jquery-browserify');

  async = require('async');

  flot = require('flot');

  validator = require('validator-extras');

  v = validator.v;

  settings = {
    websockethost: "http://" + window.location.host,
    simulatedelay: true
  };

  env = {};

  window.env = env;

  env.settings = settings;

  logger = comm.MsgNode.extend4000({
    log: function() {
      var data, tags, tagshash, text;
      text = arguments[0], data = arguments[1], tags = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      tagshash = {};
      _.map(tags, function(tag) {
        return tagshash[tag] = true;
      });
      return this.msg({
        tags: tagshash,
        text: text,
        data: data,
        time: new Date().getTime()
      });
    }
  });

  consoleLogger = consoleLogger = logger.extend4000({
    initialize: function() {
      return this.subscribe(true, function(msg, reply, next, transmit) {
        var json, text;
        text = msg.text;
        if (msg.tags.error && _.keys(msg.data).length) {
          json = " " + JSON.stringify(msg.data);
        } else {
          json = "";
        }
        console.log(_.keys(msg.tags).join(', ') + " " + text + json);
        reply.end();
        next();
        return transmit();
      });
    }
  });

  initLogger = function(env, callback) {
    env.logger = new logger();
    env.consoleLogger = new consoleLogger();
    env.logger.pass();
    env.logger.connect(env.consoleLogger);
    env.log = env.logger.log.bind(env.logger);
    env.logres = function(name, callback) {
      return function(err, data) {
        if (err) {
          env.log(name, {
            error: err
          }, 'init', 'fail');
        } else {
          env.log(name, {}, 'init', 'ok');
        }
        return callback(err, data);
      };
    };
    env.log('logger', {}, 'init', 'ok');
    return callback();
  };

  gatherInfo = function(env, callback) {
    var crawl;
    env.hostdata = {};
    crawl = function(object, attributes) {
      return helpers.hashmap(attributes, function(value, attr) {
        return object[attr];
      });
    };
    env.hostdata.browser = crawl(navigator, ['appCodeName', 'appVersion', 'userAgent', 'vendor']);
    env.hostdata.screen = crawl(window.screen, ['height', 'width', 'colorDepth']);
    env.hostdata.os = {
      platform: navigator.platform,
      language: navigator.language
    };
    return callback();
  };

  initWebsocket = function(env, callback) {
    var websocket;
    env.websocket = websocket = new comm.WebsocketClient({
      realm: 'web'
    });
    return callback();
  };

  websocketConnect = function(env, callback) {
    var doconnect;
    doconnect = function() {
      return env.websocket.connect(env.settings.websockethost, function() {
        return callback();
      });
    };
    if (window.location.hostname !== 'localhost' || env.settings.simulatedelay !== true) {
      return doconnect();
    } else {
      return setTimeout(doconnect, 400);
    }
  };

  initdict = {
    logger: function(callback) {
      return initLogger(env, callback);
    },
    gatherinfo: [
      'logger', function(callback) {
        return gatherInfo(env, env.logres('host info', callback));
      }
    ],
    websocket: [
      'logger', function(callback) {
        return initWebsocket(env, env.logres('initializing websocket', callback));
      }
    ],
    websocketconnect: [
      'websocket', function(callback) {
        return websocketConnect(env, env.logres('connecting websocket', callback));
      }
    ],
    streamreader: [
      'streamReader', function(callback) {
        return initStreamReader(env, env.logres('initializing stream reader', callback));
      }
    ]
  };

  init = function(env, callback) {
    return async.series({
      logger: function(callback) {
        return initLogger(env, callback);
      },
      gatherinfo: function(callback) {
        return gatherInfo(env, env.logres('host info', callback));
      },
      websocket: function(callback) {
        return initWebsocket(env, env.logres('initializing websocket', callback));
      },
      websocketconnect: function(callback) {
        return websocketConnect(env, env.logres('connecting websocket', callback));
      },
      streamreader: function(callback) {
        return initStreamReader(env, env.logres('initializing stream reader', callback));
      }
    }, callback);
  };

  init(env, function(err, data) {
    if (err) {
      env.log('clientside init failed', {}, 'init', 'fail', 'error');
      return;
    }
    return env.log('clientside ready', {}, 'init', 'ok', 'completed');
  });

  randomWalk = function(data, len) {
    var last;
    if (len == null) {
      len = 300;
    }
    if (!(data != null ? data.length : void 0)) {
      data = [50];
    }
    last = _.last(data);
    data.push(last + helpers.randrange(10) - 5);
    if (data.length > len) {
      data.shift();
      return data;
    } else {
      return randomWalk(data, len);
    }
  };

  cook = function(data) {
    return {
      lines: {
        show: true,
        fill: true
      },
      points: {
        show: false
      },
      data: data = _.map(data, function(n, i) {
        return [i, n];
      })
    };
  };

  getmax = function(data) {
    return _.reduce(data, function(r, x) {
      if (x > r) {
        return x;
      } else {
        return r;
      }
    });
  };

  initStreamReader = function(env, callback) {
    var DataSource, DataStream, Graph, graphs, viewModel;
    viewModel = backbone.Model.extend4000({
      associate: function(attribute, div) {
        var updatediv;
        updatediv = function(value) {
          return div.html(value);
        };
        updatediv(this.get(attribute));
        return this.on('change:' + attribute, updatediv);
      }
    });
    DataSource = comm.MsgNode.extend4000({
      defauls: {
        maxlen: 100
      },
      initialize: function() {
        var _this = this;
        this.set({
          max: 0
        });
        console.log('created new source', this.get('name'));
        this.subscribe({
          source: this.get('name')
        }, function(msg, reply) {
          reply.end();
          if (msg.push) {
            _this.push(msg.push);
          }
          if (msg.change) {
            return _this.change(msg.change);
          }
        });
        return this.data = [];
      },
      max: function() {
        return getmax(this.data);
      },
      push: function(value) {
        var max, shift;
        this.data.push(value);
        if (this.data.length > 100) {
          shift = this.data.shift();
        }
        max = this.get('max');
        if (value > max) {
          return this.set({
            max: value
          });
        } else if (shift === max) {
          return this.set({
            max: this.max()
          });
        }
      },
      change: function(value) {
        if (!this.data.length) {
          this.data.push(0);
        }
        return this.push(_.last(this.data) + value);
      },
      clear: function(callback) {
        return callback();
      },
      remoteset: function(attribute, value, callback) {
        return callback();
      },
      exportdata: function() {
        return {
          label: this.get('name'),
          lines: {
            show: true,
            fill: true
          },
          points: {
            show: false
          },
          data: _.map(this.data, function(n, i) {
            return [i, n];
          })
        };
      }
    });
    Graph = comm.MsgNode.extend4000({
      defaults: {
        max: 1
      },
      initialize: function() {
        var graphwindow, namediv,
          _this = this;
        this.sources = {};
        graphwindow = $("<div class='window'></div>");
        graphwindow.append(namediv = $("<div class='graphtitle'>" + (this.get('name')) + "</div>"));
        graphwindow.append(this.graphdiv = $("<div class='graphcontainer'></div>"));
        $(document.body).append(graphwindow);
        this.hardredraw();
        this.subscribe({
          graph: this.get('name')
        }, function(msg, reply, next, transmit) {
          var sourcenode;
          if (!msg.source) {
            msg.source = 'default';
          }
          if (!_this.sources[msg.source]) {
            sourcenode = _this.sources[msg.source] = new DataSource({
              name: msg.source
            });
            _this.connect(sourcenode);
            sourcenode.msg({
              test: 'msg'
            });
            sourcenode.on('change:max', function(stream, streammax) {
              var max;
              max = _this.get('max');
              if (streammax > max) {
                _this.set({
                  max: streammax
                });
              }
              if (streammax === max) {
                return _this.set({
                  max: _this.max()
                });
              }
            });
          }
          reply.end();
          transmit();
          return _this.redraw();
        });
        return this.on('change:max', function(self, value) {
          window.plot = this.plot;
          return this.hardredraw();
        });
      },
      max: function() {
        return getmax(_.map(this.sources, function(source) {
          return source.get('max');
        }));
      },
      hardredraw: function() {
        var max;
        max = this.get('max');
        max = (max / 10.0) * 11;
        return this.plot = $.plot(this.graphdiv, this.exportdata(), {
          series: {
            shadowSize: 0
          },
          yaxis: {
            show: true,
            min: 0,
            max: max
          },
          xaxis: {
            show: true,
            min: 0,
            max: 100
          },
          legend: {
            position: "sw"
          }
        });
      },
      redraw: function() {
        this.plot.setData(this.exportdata());
        return this.plot.draw();
      },
      exportdata: function() {
        return _.map(this.sources, function(source) {
          return source.exportdata();
        });
      }
    });
    DataStream = (function() {

      function DataStream(init) {
        var graphwindow,
          _this = this;
        this.maxlen = init.maxlen || 200;
        this.name = init.name || (function() {
          throw 'no name?';
        })();
        this.data = init.data || [0];
        graphwindow = $("<div class='window'></div>");
        graphwindow.append($("<div class='graphtitle'>" + this.name + "</div>"));
        graphwindow.append(this.div = $("<div class='graphcontainer'></div>"));
        $(document.body).append(graphwindow);
        this.plot = $.plot(this.div, [cook(this.data)], {
          series: {
            shadowSize: 0
          },
          yaxis: {
            show: false,
            min: 0,
            max: 1
          },
          xaxis: {
            show: false,
            min: 0,
            max: this.maxlen
          }
        });
        env.websocket.subscribe({
          graph: this.name,
          add: true
        }, function(msg, reply) {
          reply.end();
          return _this.push(msg.add);
        });
        env.websocket.subscribe({
          graph: this.name,
          change: true
        }, function(msg, reply) {
          reply.end();
          return _this.change(msg.change);
        });
        env.websocket.subscribe({
          graph: this.name,
          maxlen: true
        }, function(msg, reply, next) {
          reply.end();
          next();
          _this.maxlen = msg.maxlen;
          while (_this.data.length - 1 > _this.maxlen) {
            _this.data.shift();
          }
          return _this.redraw();
        });
        env.websocket.subscribe({
          graph: this.name,
          clear: true
        }, function(msg, reply, next) {
          reply.end();
          next();
          return _this.data = [0];
        });
      }

      DataStream.prototype.redraw = function() {
        this.plot.setData([cook(this.data)]);
        return this.plot.draw();
      };

      DataStream.prototype.push = function(value) {
        this.data.push(value);
        if (this.data.length - 1 > this.maxlen) {
          this.data.shift();
        }
        return this.redraw();
      };

      DataStream.prototype.change = function(value) {
        this.data.push(_.last(data) + value);
        if (this.data.length - 1 > this.maxlen) {
          this.data.shift();
        }
        return this.redraw();
      };

      return DataStream;

    })();
    graphs = {};
    env.websocket.subscribe({
      graph: true
    }, function(msg, reply, next, transmit) {
      var graph;
      if (!graphs[msg.graph]) {
        graph = graphs[msg.graph] = new Graph({
          name: msg.graph
        });
        console.log('created new graph', msg.graph, graphs);
        graph.connect(env.websocket);
      }
      reply.end();
      next();
      return transmit();
    });
    return callback();
  };

}).call(this);
